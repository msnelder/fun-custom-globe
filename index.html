<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Globe</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: transparent; }
    canvas { display: block; width: 100% !important; height: 100% !important; }
  </style>
</head>
<body>
  <script type="importmap">
    { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js" } }
  </script>

  <script type="module">
    import * as THREE from 'three';

    // ─── Renderer ────────────────────────────────────────────────────────────
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0);
    document.body.appendChild(renderer.domElement);

    // ─── Scene & Camera ──────────────────────────────────────────────────────
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.z = 3;

    // ─── Globe group ─────────────────────────────────────────────────────────
    const globe = new THREE.Group();
    scene.add(globe);

    // ─── Base sphere (near-black) ─────────────────────────────────────────────
    const sphereGeo = new THREE.SphereGeometry(1, 64, 64);
    globe.add(new THREE.Mesh(
      sphereGeo,
      new THREE.MeshStandardMaterial({ color: 0x06080f, roughness: 0.9, metalness: 0.0 })
    ));

    // ─── Rim / glimmer (Fresnel shader) ───────────────────────────────────────
    globe.add(new THREE.Mesh(
      sphereGeo,
      new THREE.ShaderMaterial({
        vertexShader: `
          varying vec3 vNormal;
          void main() {
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          varying vec3 vNormal;
          void main() {
            float rim = 1.0 - max(0.0, dot(vNormal, vec3(0.0, 0.0, 1.0)));
            rim = pow(rim, 3.5);
            float glimmer = clamp(0.4 + vNormal.y * 0.4 - vNormal.x * 0.3, 0.0, 1.0);
            vec3 color = mix(vec3(0.3, 0.35, 0.5), vec3(0.75, 0.85, 1.0), glimmer);
            gl_FragColor = vec4(color, rim * 0.55);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      })
    ));

    // ─── Lights ──────────────────────────────────────────────────────────────
    scene.add(new THREE.AmbientLight(0xffffff, 0.06));
    const dirLight = new THREE.DirectionalLight(0x8899cc, 0.35);
    dirLight.position.set(-4, 3, 4);
    scene.add(dirLight);

    // ─── Random dots with per-point size & opacity ───────────────────────────
    const DOT_COUNT = 850;
    const positions = new Float32Array(DOT_COUNT * 3);
    const opacities = new Float32Array(DOT_COUNT);
    const sizes     = new Float32Array(DOT_COUNT);
    const dpr       = renderer.getPixelRatio();

    for (let i = 0; i < DOT_COUNT; i++) {
      // Uniform random point on sphere (not biased toward poles)
      const u     = Math.random();
      const v     = Math.random();
      const theta = 2 * Math.PI * u;
      const phi   = Math.acos(2 * v - 1);
      const r     = 1.002; // just above sphere surface

      positions[i * 3]     = r * Math.sin(phi) * Math.cos(theta);
      positions[i * 3 + 1] = r * Math.cos(phi);
      positions[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);

      // Opacity: spread across the full range — most in the mid zone
      opacities[i] = 0.08 + Math.random() * 0.92;

      // Size: mostly small, occasional medium/large dot
      const roll  = Math.random();
      const px    = roll < 0.60 ? 1.5 + Math.random() * 2.0   // small  1.5–3.5 px
                  : roll < 0.88 ? 3.5 + Math.random() * 2.5   // medium 3.5–6 px
                  :               6.0 + Math.random() * 3.0;  // large  6–9 px
      sizes[i] = px * dpr;
    }

    const dotsGeo = new THREE.BufferGeometry();
    dotsGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    dotsGeo.setAttribute('aOpacity', new THREE.BufferAttribute(opacities, 1));
    dotsGeo.setAttribute('aSize',    new THREE.BufferAttribute(sizes, 1));

    const dotsMat = new THREE.ShaderMaterial({
      vertexShader: `
        attribute float aOpacity;
        attribute float aSize;
        varying float vOpacity;

        void main() {
          vOpacity = aOpacity;
          gl_PointSize = aSize;
          gl_Position  = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        varying float vOpacity;

        void main() {
          // Circular dot with soft falloff
          vec2  uv = gl_PointCoord - vec2(0.5);
          float r  = length(uv);
          if (r > 0.5) discard;
          float alpha = 1.0 - smoothstep(0.25, 0.5, r);
          gl_FragColor = vec4(1.0, 1.0, 1.0, alpha * vOpacity);
        }
      `,
      transparent: true,
      depthWrite:  false,
      blending:    THREE.NormalBlending,
    });

    globe.add(new THREE.Points(dotsGeo, dotsMat));

    // ─── Resize ──────────────────────────────────────────────────────────────
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ─── Animate ─────────────────────────────────────────────────────────────
    (function animate() {
      requestAnimationFrame(animate);
      globe.rotation.y += 0.0018;
      renderer.render(scene, camera);
    })();
  </script>
</body>
</html>
