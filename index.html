<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Globe</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: transparent; }
    canvas { display: block; width: 100% !important; height: 100% !important; }
  </style>
</head>
<body>
  <!-- topojson as plain UMD script — much more reliable than importmap -->
  <script src="https://cdn.jsdelivr.net/npm/topojson-client@3/dist/topojson-client.min.js"></script>

  <script type="importmap">
    { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js" } }
  </script>

  <script type="module">
    import * as THREE from 'three';

    // ─── Renderer ────────────────────────────────────────────────────────────
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0);
    document.body.appendChild(renderer.domElement);

    // ─── Scene & Camera ──────────────────────────────────────────────────────
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.z = 3;

    // ─── Globe group ─────────────────────────────────────────────────────────
    const globe = new THREE.Group();
    scene.add(globe);

    // ─── Base sphere (near-black) ─────────────────────────────────────────────
    const sphereGeo = new THREE.SphereGeometry(1, 64, 64);
    globe.add(new THREE.Mesh(
      sphereGeo,
      new THREE.MeshStandardMaterial({ color: 0x06080f, roughness: 0.9, metalness: 0.0 })
    ));

    // ─── Rim / glimmer (Fresnel shader) ───────────────────────────────────────
    globe.add(new THREE.Mesh(
      sphereGeo,
      new THREE.ShaderMaterial({
        vertexShader: `
          varying vec3 vNormal;
          void main() {
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          varying vec3 vNormal;
          void main() {
            float rim = 1.0 - max(0.0, dot(vNormal, vec3(0.0, 0.0, 1.0)));
            rim = pow(rim, 3.5);
            float glimmer = clamp(0.4 + vNormal.y * 0.4 - vNormal.x * 0.3, 0.0, 1.0);
            vec3 color = mix(vec3(0.3, 0.35, 0.5), vec3(0.75, 0.85, 1.0), glimmer);
            gl_FragColor = vec4(color, rim * 0.55);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      })
    ));

    // ─── Lighting ────────────────────────────────────────────────────────────
    scene.add(new THREE.AmbientLight(0xffffff, 0.06));
    const dirLight = new THREE.DirectionalLight(0x8899cc, 0.35);
    dirLight.position.set(-4, 3, 4);
    scene.add(dirLight);

    // ─── Animate (starts immediately, dots added once loaded) ────────────────
    let animId;
    (function animate() {
      animId = requestAnimationFrame(animate);
      globe.rotation.y += 0.0018;
      renderer.render(scene, camera);
    })();

    // ─── Resize ──────────────────────────────────────────────────────────────
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ─── Land dots (async — sphere is already spinning while this loads) ──────
    async function buildDots() {
      const MASK_W = 2048, MASK_H = 1024;
      const maskCanvas = document.createElement('canvas');
      maskCanvas.width = MASK_W;
      maskCanvas.height = MASK_H;
      const mctx = maskCanvas.getContext('2d');
      mctx.fillStyle = '#000';
      mctx.fillRect(0, 0, MASK_W, MASK_H);
      mctx.fillStyle = '#fff';

      // Fetch world topology
      const world = await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json')
        .then(r => r.json());

      // topojson loaded as global UMD script
      const land = topojson.feature(world, world.objects.land);

      function drawGeom(geom) {
        if (geom.type === 'Polygon') drawRing(geom.coordinates[0]);
        else if (geom.type === 'MultiPolygon') geom.coordinates.forEach(p => drawRing(p[0]));
      }

      function drawRing(ring) {
        mctx.beginPath();
        const [x0, y0] = project(ring[0]);
        mctx.moveTo(x0, y0);
        for (let i = 1; i < ring.length; i++) {
          const [x, y] = project(ring[i]);
          mctx.lineTo(x, y);
        }
        mctx.closePath();
        mctx.fill();
      }

      function project([lng, lat]) {
        return [((lng + 180) / 360) * MASK_W, ((90 - lat) / 180) * MASK_H];
      }

      drawGeom(land.geometry);

      // Sample land pixels → 3D sphere positions
      const pixels = mctx.getImageData(0, 0, MASK_W, MASK_H).data;
      const positions = [];
      const LAT_STEP = 1.8;

      for (let lat = -90 + LAT_STEP / 2; lat < 90; lat += LAT_STEP) {
        const cosLat = Math.cos((lat * Math.PI) / 180);
        const lngStep = LAT_STEP / Math.max(cosLat, 0.05);

        for (let lng = -180; lng < 180; lng += lngStep) {
          const px = Math.min(MASK_W - 1, Math.floor(((lng + 180) / 360) * MASK_W));
          const py = Math.min(MASK_H - 1, Math.floor(((90 - lat) / 180) * MASK_H));

          if (pixels[(py * MASK_W + px) * 4] > 128) {
            const phi   = ((90 - lat) * Math.PI) / 180;
            const theta = ((lng + 180) * Math.PI) / 180;
            const r     = 1.001;
            positions.push(
              r * Math.sin(phi) * Math.cos(theta),
              r * Math.cos(phi),
              r * Math.sin(phi) * Math.sin(theta)
            );
          }
        }
      }

      // Circular dot sprite
      const dotCanvas = document.createElement('canvas');
      dotCanvas.width = dotCanvas.height = 64;
      const dctx = dotCanvas.getContext('2d');
      const grad = dctx.createRadialGradient(32, 32, 0, 32, 32, 30);
      grad.addColorStop(0,    'rgba(255,255,255,1)');
      grad.addColorStop(0.45, 'rgba(255,255,255,0.9)');
      grad.addColorStop(1,    'rgba(255,255,255,0)');
      dctx.fillStyle = grad;
      dctx.fillRect(0, 0, 64, 64);

      const dotsGeo = new THREE.BufferGeometry();
      dotsGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

      globe.add(new THREE.Points(dotsGeo, new THREE.PointsMaterial({
        color: 0x52606e,
        size: 0.017,
        sizeAttenuation: true,
        map: new THREE.CanvasTexture(dotCanvas),
        transparent: true,
        alphaTest: 0.05,
        depthWrite: false,
      })));
    }

    buildDots().catch(err => console.warn('Dots failed to load:', err));
  </script>
</body>
</html>
