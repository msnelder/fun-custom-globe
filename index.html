<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Globe</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: transparent; }
    body.has-bg { background: var(--preview-bg); }
    canvas { display: block; width: 100% !important; height: 100% !important; }
  </style>
</head>
<body>
  <script type="importmap">
    { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js" } }
  </script>

  <script type="module">
    import * as THREE from 'three';

    // ─── Preview background via ?bg= URL param ───────────────────────────────
    const bg = new URLSearchParams(location.search).get('bg');
    if (bg) {
      document.body.style.setProperty('--preview-bg', `#${bg.replace(/^#/, '')}`);
      document.body.classList.add('has-bg');
    }

    // ─── Renderer ────────────────────────────────────────────────────────────
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0);
    document.body.appendChild(renderer.domElement);

    // ─── Scene & Camera ──────────────────────────────────────────────────────
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.z = 3;

    // ─── Globe group ─────────────────────────────────────────────────────────
    const globe = new THREE.Group();
    scene.add(globe);

    const sphereGeo = new THREE.SphereGeometry(1, 64, 64);

    // ─── Base sphere with inner glow ─────────────────────────────────────────
    // A directional gradient — dark on most of the sphere, soft glow on one
    // side — fixed in view space so it doesn't rotate with the globe.
    globe.add(new THREE.Mesh(
      sphereGeo,
      new THREE.ShaderMaterial({
        vertexShader: `
          varying vec3 vNormal;
          void main() {
            // View-space normal — stays fixed relative to camera as globe spins
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          varying vec3 vNormal;
          void main() {
            // Glow direction: upper-left, toward viewer (matches screenshot)
            vec3 glowDir = normalize(vec3(-0.55, 0.25, 0.85));
            float glow   = max(0.0, dot(vNormal, glowDir));
            glow         = pow(glow, 2.0);

            vec3 dark    = vec3(0.020, 0.025, 0.040); // near-black base
            vec3 lit     = vec3(0.160, 0.190, 0.280); // soft blue-grey glow
            gl_FragColor = vec4(mix(dark, lit, glow * 0.75), 1.0);
          }
        `,
      })
    ));

    // ─── Rim / glimmer (Fresnel shader) ──────────────────────────────────────
    globe.add(new THREE.Mesh(
      sphereGeo,
      new THREE.ShaderMaterial({
        vertexShader: `
          varying vec3 vNormal;
          void main() {
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          varying vec3 vNormal;
          void main() {
            float rim     = 1.0 - max(0.0, dot(vNormal, vec3(0.0, 0.0, 1.0)));
            rim           = pow(rim, 3.5);
            float glimmer = clamp(0.4 + vNormal.y * 0.4 - vNormal.x * 0.3, 0.0, 1.0);
            vec3 color    = mix(vec3(0.3, 0.35, 0.5), vec3(0.75, 0.85, 1.0), glimmer);
            gl_FragColor  = vec4(color, rim * 0.55);
          }
        `,
        transparent: true,
        blending:    THREE.AdditiveBlending,
        depthWrite:  false,
      })
    ));

    // ─── Random dots — uniform size, varying opacity, depth-faded ───────────
    const DOT_COUNT = 850;
    const positions = new Float32Array(DOT_COUNT * 3);
    const opacities = new Float32Array(DOT_COUNT);
    const dpr       = renderer.getPixelRatio();

    for (let i = 0; i < DOT_COUNT; i++) {
      const theta = 2 * Math.PI * Math.random();
      const phi   = Math.acos(2 * Math.random() - 1);
      const r     = 1.002;
      positions[i * 3]     = r * Math.sin(phi) * Math.cos(theta);
      positions[i * 3 + 1] = r * Math.cos(phi);
      positions[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
      opacities[i] = 0.08 + Math.random() * 0.92;
    }

    const dotsGeo = new THREE.BufferGeometry();
    dotsGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    dotsGeo.setAttribute('aOpacity', new THREE.BufferAttribute(opacities, 1));

    const dotsMat = new THREE.ShaderMaterial({
      uniforms: {
        uSize: { value: 4.2 * dpr }, // uniform size for all dots
      },
      vertexShader: `
        uniform float uSize;
        attribute float aOpacity;
        varying float vOpacity;

        void main() {
          vec4 mvPos = modelViewMatrix * vec4(position, 1.0);

          // Depth fade: front dots full brightness, back dots ~30% — sells the 3D
          float depth     = clamp((-mvPos.z - 2.0) / 2.0, 0.0, 1.0);
          float depthFade = 0.3 + 0.7 * (1.0 - depth);
          vOpacity = aOpacity * depthFade;

          gl_PointSize = uSize;
          gl_Position  = projectionMatrix * mvPos;
        }
      `,
      fragmentShader: `
        varying float vOpacity;

        void main() {
          vec2  uv = gl_PointCoord - vec2(0.5);
          float r  = length(uv);
          if (r > 0.5) discard;
          float alpha = 1.0 - smoothstep(0.25, 0.5, r);
          gl_FragColor = vec4(1.0, 1.0, 1.0, alpha * vOpacity);
        }
      `,
      transparent: true,
      depthWrite:  false,
      blending:    THREE.NormalBlending,
    });

    globe.add(new THREE.Points(dotsGeo, dotsMat));

    // ─── Resize ──────────────────────────────────────────────────────────────
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ─── Animate ─────────────────────────────────────────────────────────────
    (function animate() {
      requestAnimationFrame(animate);
      globe.rotation.y += 0.0003;
      renderer.render(scene, camera);
    })();
  </script>
</body>
</html>
